# Разбор решения Maximum Gap (LeetCode 164)

Для решения задачи за время $O(N)$ и с использованием дополнительной памяти $O(N)$ используется концепция **Bucket Sort (корзинная сортировка)** и **Принцип Дирихле**.

Обычная сортировка заняла бы $O(N \log N)$, поэтому мы избегаем полного упорядочивания массива.

## Ход алгоритма

**1. Базовые проверки**
Если длина массива меньше 2 элементов, возвращаем `0`, так как вычислить разницу невозможно.

**2. Поиск границ (`mn` и `mx`)**
Мы один раз проходим по массиву, чтобы найти минимальное (`mn`) и максимальное (`mx`) значения. Это определит общий диапазон наших чисел.

**3. Вычисление параметров бакетов (`sz` и `cnt`)**
Мы знаем, что максимальная разница между соседними элементами в отсортированном массиве *не может быть меньше*, чем средняя разница. 
Средняя разница вычисляется как: `(mx - mn) / (N - 1)`.
Мы берем это значение за размер бакета (`sz`). Это гарантирует важную вещь: **максимальный разрыв всегда будет находиться между элементами из разных бакетов**, а не внутри одного. Количество бакетов (`cnt`) покрывает весь диапазон.

**4. Инициализация и заполнение бакетов (`b`)**
Мы создаем массив бакетов. В каждом бакете нам не нужно хранить все попавшие туда числа - достаточно знать только локальный **минимум** и **максимум**. 
- Изначально минимум равен бесконечности (`math.MaxInt64`), а максимум - минус бесконечности (`math.MinInt64`).
- Распределяем числа по бакетам по формуле: `idx = (v - mn) / sz`.

**5. Поиск максимального разрыва (`ans`)**
Проходим по всем бакетам по порядку:
- Если бакет пуст (минимум остался равен бесконечности), просто пропускаем его.
- Если бакет не пуст, вычисляем разницу между **минимумом текущего бакета** и **максимумом предыдущего непустого бакета** (`prev`).
- Обновляем максимальный разрыв (`ans`) и перезаписываем `prev` максимумом текущего бакета для следующей итерации.

В конце возвращаем найденный `ans`.